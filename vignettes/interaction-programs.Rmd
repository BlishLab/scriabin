---
title: "Discovery of co-varying interaction programs"
author: "Aaron J. Wilk"
date: "2021-01-20"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{interaction-programs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Here we will illustrate the third Scriabin workflow: 

Load libraries

```{r}
library(Seurat)
library(SeuratData)
library(scriabin)
library(tidyverse)
library(ComplexHeatmap)
library(cowplot)
```

We will find 
To install the panc8 dataset:
```{r}
if (!requireNamespace("panc8.SeuratData", quietly = TRUE))
  install.packages("https://seurat.nygenome.org/src/contrib/panc8.SeuratData_3.0.2.tar.gz", repos = NULL, type = "source") 
library(panc8.SeuratData)
panc8 <- LoadData("panc8")
```



```{r}
panc_id <- subset(panc8, cells = colnames(panc8)[panc8$tech=="indrop"])
panc_id <- SCTransform(panc_id, verbose = F) %>%
  RunPCA(verbose = F) %>%
  RunUMAP(dims = 1:30, verbose = F)
DimPlot(panc_id, group.by = "celltype", label = T, repel = T) + NoLegend()
```

Now we find interaction programs, score them for statistical significance, and then score all single cells in the dataset on the expression of these programs

One important parameter in the interaction program discovery workflow is the soft thresholding power (softPower) used in generating the adjacency matrix for interaction program discovery. In traditional gene correlation network analyses, soft thresholding increases the degree of gene-gene connectivity required to form a module, thereby lowering the influence of spurious correlations within the similarity matrix. The authors of WGCNA have recommended utilizing the lowest softPower that results in a scale-free topology fitting index (R2) of greater than 0.822. 

Because a single ligand can interact with multiple receptors, and vice versa, the variables of a CCIM that are used to calculate the similarity matrix for WGCNA are not independent. We hypothesized that using the same soft thresholding guidelines as recommended for WGCNA may result in highly connected interaction programs where only a single ligand or receptor is represented. We thus evaluated the impact of the R2 threshold on interaction program size, composition, and statistical significance. 

We found that, at the standard R2 = 0.8 threshold, the mean recommended softPower was 3, and this decreased as the R2 threshold decreased (Supplementary Figure 11D). Higher R2 thresholds were associated with smaller program sizes, particularly when R2 > 0.5, and there was a moderate increase in the percentage of programs composed of only 1 ligand or receptor with increasing R2 thresholds. Additionally, we observed that decreasing the R2 threshold led to a moderate increase in the percentage of non-statistically significant programs, indicative of spurious correlations. These data indicate that an optimal R2 threshold to avoid both spurious programs as well as programs composed of only a single ligand or receptor may lie between 0.5 and 0.75. 

The default R2 for interaction program discovery is now set at 0.6, which is used by the functions `InteractionPrograms` and `FindAllInteractionPrograms`. 

```{r}
#find interaction programs
panc_ip <- InteractionPrograms(panc_id, iterate.threshold = 300)

#test for interaction program significance
panc_ip_sig <- InteractionProgramSignificance(panc_ip, n.replicate = 500)

#score cells by expression of interaction program
panc_id <- ScoreInteractionPrograms(panc_id, panc_ip_sig)
```

Let's visualize average expression of these interaction programs per cell type

```{r}
panc_id_ip_lig <- as.matrix(panc_id@meta.data %>% 
  select("celltype",
         starts_with("ligands")) %>%
  group_by(celltype) %>%
  summarise_if(is.numeric, mean) %>% column_to_rownames("celltype"))
Heatmap(panc_id_ip_lig, show_column_names = F)

panc_id_ip_rec <- as.matrix(panc_id@meta.data %>% 
  select("celltype",
         starts_with("receptors")) %>%
  group_by(celltype) %>%
  summarise_if(is.numeric, mean) %>% column_to_rownames("celltype"))
Heatmap(panc_id_ip_rec, show_column_names = F)
```

We find several modules with shared expression patterns in stellate cells, but higher expression in activated vs. quiescent stellate cells. Who do they communicate with?

```{r}
act_stellate_ip <- panc_id_ip_lig["activated_stellate",]
poi <- gsub("ligands_","",names(which(act_stellate_ip==max(act_stellate_ip))))

#Seurat's FeaturePlot has a nice option to blend expression of two features together on the same plot
p <- FeaturePlot(panc_id, 
          features = c(paste0("ligands_",poi),
                            paste0("receptors_",poi)), 
          blend = T, combine = F, 
          cols = c("grey90","purple","yellowgreen"), order = T)
p[[3]] + NoLegend()

DimPlot(panc_id, group.by = "celltype", label = T, repel = T) + NoLegend()
```

In this module we see highly specific ligand expression by activated stellate cells which send to endothelial cells. Let's take a look at the genes within this module. 

```{r}
moi <- reshape2::melt(panc_ip_sig %>% dplyr::filter(name==poi) %>%
  select("lr_pair",contains("connectivity"))) %>% arrange(-value)
moi$lr_pair <- factor(moi$lr_pair, levels = unique(moi$lr_pair))
ggplot(moi, aes(x = lr_pair, y = value, color = variable)) + 
  geom_point() + theme_cowplot() + ggpubr::rotate_x_text() + labs(x = NULL, y = "Intramodular\nconnectivity")
```

Identify high scoring modules paired across cell types by summing average ligand and receptor program score across all cell types

```{r}
#matrix addition at baseline will represent autocrine signaling.
#by shuffling the row order in one matrix, we can calculate high scores across cells
ip_interact = list()
row_orders = sapply(0:nrow(panc_id_ip_lig)-1, function(x) c((1 + x):nrow(panc_id_ip_lig), seq_len(x))) #create matrix of row shufflings
for (i in 1:nrow(panc_id_ip_lig)){
  ip_interact[[i]] = panc_id_ip_lig[row_orders[i,],] + panc_id_ip_rec
}

#example distribution of ligand+receptor scores
hist(ip_interact[[sample(1:nrow(panc_id_ip_lig, 1))]], breaks = 30)

#pick out indices in each where the sum is > 0.5 and export table
interact.cutoff = 0.5
all.poi.list = lapply(ip_interact, function(mat){
  hits.ind = which(mat >interact.cutoff, arr.ind = TRUE)
  hits = data.frame(sender = rownames(mat)[hits.ind[,1]], 
                    receiver = rownames(panc_id_ip_rec)[hits.ind[,1]],
                    program = gsub("ligands_","", x = colnames(mat)[hits.ind[,2]]),
                    additive.score = apply(hits.ind, 1, function(inds) mat[inds[1],inds[2]]))
  return(hits)
})
all.poi = do.call(rbind, all.poi.list)
```
